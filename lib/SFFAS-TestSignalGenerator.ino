// /*--------------------------------------------------------------------
//   This file is part of the HAN IoT shield library.

//   This code is free software:
//   you can redistribute it and/or modify it under the terms of a Creative
//   Commons Attribution-NonCommercial 4.0 International License
//   (http://creativecommons.org/licenses/by-nc/4.0/) by
//   Remko Welling (https://ese.han.nl/~rwelling/) E-mail: remko.welling@han.nl

//   The program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//   --------------------------------------------------------------------*/

// /*!
//  * \file SFFAS-TestSignalGenerator.ino
//  * \brief Sends packets on TTN using the HAN IoT Shield.
//  * this sketch is made to demonstrate the functionalities of the IoT Shield
//  * that is used in the IoT class of Embedded Systems. It delivers a library 
//  * to allow studens to easily use the IoT shield and explore the interfaces
//  * that are used to work with the IoT shield.
//  * \author Remko Welling (remko.welling@han.nl)
//  * \date 14-1-2019
//  * \version 9
//  */
//  #define RELEASE   10    ///< Software version of the sketch
// /*!
//  * Version|Date        |Note
//  * -------|------------|----
//  * 10     | 12-3-2020  | added remote reset of node using downlink and watchdog
//  * 9      | 22-2-2019  | Modification to use devEui generated by TTN. This requires the modified 
//  *        |            | TheThingsNetwork class that shall be used \ locally.
//  *        |            | The normal The Things Network library cannot be used!
//  * 8      | 4-2-2019   | Modified include "arduino.h" to "Arduino.h" to be linux compliant
//  * 7      | 14-1-2019  | Modified interval sending to Cayenne to adapt interval range in seconds 
//  *        |            | to fit float of analog in (actually uitn16_t under the hood)
//  * 6      | 10-1-2019  | Added downlink, sanity check, added documentation
//  * 5      | 20-12-2018 | First released version
//  * 
//  * 
//  */

// #include "TheThingsNetwork_HANIoT.h"
// #include <CayenneLPP.h>
// #include <avr/wdt.h>  // Watchdog 

// #include "HAN_IoT_SignalGenerator.h"
// #include "HAN_IoT_Shield.h"
// #include "PE1MEW_Timer.h"

// // Configure TTN
// // =============
// // Set your DevEUI, AppEUI and AppKey

// const char *devEui = "0000000000000000";                  ///< devEUI to be generated by TTN Console
// const char *appEui = "0000000000000000";                  ///< appEUI retrieve from TTN Console application
// const char *appKey = "00000000000000000000000000000000";  ///< appKEY rtrieve from TTN Console application

// #define loraSerial Serial1
// #define debugSerial Serial

// // Replace REPLACE_ME with TTN_FP_EU868 or TTN_FP_US915
// #define freqPlan TTN_FP_EU868

// TheThingsNetwork_HANIoT ttn(loraSerial, debugSerial, freqPlan);

// // Configure CayenneLPP
// // ====================
// // Application port of Cayenne
// #define APPLICATION_PORT_CAYENNE  99  ///< LoRaWAN port to which CayenneLPP packets shall be sent
// #define LPP_PAYLOAD_MAX_SIZE      51  ///< Maximum payload size of a LoRaWAN packet

// #define LPP_CH_BOARDVCCVOLTAGE   0    ///< CayenneLPP CHannel for VCC od RN2483 radio 
// #define LPP_CH_BOARDTEMPERATURE  1    ///< CayenneLPP CHannel for Dallas temperature sensor
// #define LPP_CH_ADC0VOLTAGE      10    ///< CayenneLPP CHannel for ADC input 1 (potmeter 1)
// #define LPP_CH_ADC1VOLTAGE      11    ///< CayenneLPP CHannel for ADC input 2 (potmeter 2)
// #define LPP_CH_TESTSIGNAL1      50    ///< CayenneLPP CHannel for Sine waveform
// #define LPP_CH_TESTSIGNAL2      52    ///< CayenneLPP CHannel for Cosine waveform
// #define LPP_CH_TESTSIGNAL3      53    ///< CayenneLPP CHannel for Triangle waveform
// #define LPP_CH_TESTSIGNAL4      54    ///< CayenneLPP CHannel for Rectangle waveform
// #define LPP_CH_TESTSIGNAL5      55    ///< CayenneLPP CHannel for Sawtooth waveform
// #define LPP_CH_PRESENCE         60    ///< CayenneLPP CHannel for Alarm
// #define LPP_CH_SET_INTERVAL     91    ///< CayenneLPP CHannel for setting downlink interval
// #define LPP_CH_SW_RELEASE       90    ///< 

// #define ALARM                   0x01  ///< Alarm state
// #define SAFE                    0x00  ///< No-alarm state

// CayenneLPP lpp(LPP_PAYLOAD_MAX_SIZE);

// // Configure Signalgenerator
// // =========================
// sine sineSignal(-100.0, 100.0);
// cosine cosineSignal(-100.0, 100.0);
// triangle triangleSignal(-100.0, 100.0);
// rectangle rectangleSignal(-100.0, 100.0);
// sawtooth sawtoothSignal(-100.0, 100.0);

// // Configure HAN IoT Shield
// // =========================
// iotShieldPotmeter potmeter1(PIN_POT_RED, -20, 500);
// iotShieldPotmeter potmeter2(PIN_POT_WHITE, 0, 100);

// iotShieldButton redButton(PIN_SWITCH_RED);
// iotShieldButton blackButton(PIN_SWITCH_BLACK);

// iotShieldLED leftRedLED(PIN_LED_1_RED);
// iotShieldLED rightRedLED(PIN_LED_2_RED);
// iotShieldLED leftGreenLED(PIN_LED_3_GRN);
// iotShieldLED rightGreenLED(PIN_LED_4_GRN);

// iotShieldTempSensor temperatureSensor;

// // Configure Timer for main loop
// // =============================
// PE1MEW_Timer mainTimer;

// // Set up application specific
// #define REGULAR_INTERVAL  60000   ///< Regular transmission interval in ms
// #define MINIMUM_INTERVAL  30000   ///< minimum allowed interval in ms
// uint32_t currentInterval = REGULAR_INTERVAL;
// uint32_t nextInterval = REGULAR_INTERVAL;

// void setup()
// {
//   loraSerial.begin(57600);
//   debugSerial.begin(9600);

//   // Wait a maximum of 10s for Serial Monitor
//   while (!debugSerial && millis() < 10000)
//     ;

//   // Setup watchdog
//   MCUSR = 0;
//   wdt_disable();
  
//   // Send "Hello World" on leds to indicate the system is ready.
//   helloWorld();

//   // Indicate that join process is running
//   rightRedLED.setState(LED_ON);
  
//   // Set callback for incoming messages
//   ttn.onMessage(messageReceived);

//   debugSerial.println(F("-- STATUS"));
//   ttn.showStatus();

//   debugSerial.println(F("-- JOIN"));
//   ttn.join(devEui, appEui, appKey);

//   // Indicate that join process is finished
//   rightRedLED.setState(LED_OFF);
  
//   // set main timer
//   mainTimer.setExpiry(2000);
// }

// void loop()
// {
//   currentInterval = nextInterval;
  
//   // Main activity, send message at regular interval
//   if(mainTimer.getExpired())
//   {
//     debugSerial.println(F("-- LOOP"));
    
//     // cleanup previous alarm and message status
//     leftRedLED.setState(LED_OFF);
//     leftGreenLED.setState(LED_OFF);
//     rightRedLED.setState(LED_OFF);
//     rightGreenLED.setState(LED_OFF);
    
//     // send message
//     sendMessage();

//     // set main timer for next message
//     mainTimer.setExpiry(currentInterval);
//     debugSerial.print("Next transmission set to: " + String(currentInterval/1000));
//     debugSerial.println(F(" Seconds"));  
//   }

//   // Manual intervention, send poll to test for downlink messages
//   // Between regular interval messages.
//   if(blackButton.isPressed())
//   {
//     debugSerial.println(F("-- SEND POLL"));
//     sendPoll();
//   }

//   // Manual intervention, send message because of alarm(?)
//   // Between regular interval messages.
//   if(redButton.isPressed())
//   {
//     leftRedLED.setState(LED_ON);
//     debugSerial.println(F("-- SEND ALARM"));
//     sendAlarm();
//   }

//   delay(1000);
// }

// /// \brief process downlink message
// /// \param payload pointer to payload
// /// \param size size of payload
// /// \param apliaction port to which payload was addressed
// void messageReceived(const uint8_t *payload, size_t size, port_t port)
// {
//   leftGreenLED.setState(LED_ON);
  
//   debugSerial.println(F("-- MESSAGE"));
//   debugSerial.print("Received " + String(size) + " bytes on port " + String(port) + ": ");

//   switch(port)
//   {
//     case 99:  // Command over Cayenne
//       if(payload[0] == LPP_CH_SET_INTERVAL)
//       {
//         uint32_t tempValue = 0;
//         tempValue |= payload[1] << 8;
//         tempValue |= payload[2];
//         nextInterval = tempValue * 10;
//         // prevent interval setting below 30 seconds.
//         if(nextInterval < MINIMUM_INTERVAL)
//         {
//           nextInterval = MINIMUM_INTERVAL;
//         }
//         debugSerial.print("Interval set: " + String(nextInterval/1000));
//         debugSerial.println(F(" seconds"));
//         leftRedLED.setState(LED_ON);
//       }
//       else
//       {
//         debugSerial.println(F("Wrong downlink message."));
//       }
//       break;

//     case 2: // Command from console
//       if(payload[0] == 0x01){
//         debugSerial.println(F("Remote reset initiated"));
//         remoteReset();
//       }
//       else
//       {
//         debugSerial.println(F("Unknown command"));
//       }
//       break;

//     default:
//       {
//         for (int i = 0; i < (int)size; i++)
//         {
//           debugSerial.print(" " + String(payload[i]));
//         }
//         debugSerial.println();
//       }
//       break;
//   }
// }

// /// \brief send interval driven message
// /// This message contains a payload with all available information.
// void sendMessage(void)
// {
//   lpp.reset();
//   lpp.addAnalogInput(LPP_CH_BOARDVCCVOLTAGE, ttn.getVDD()/1000.0);
//   lpp.addTemperature(LPP_CH_BOARDTEMPERATURE, temperatureSensor.getTemperatureCelsius());
//   lpp.addTemperature(LPP_CH_ADC0VOLTAGE, potmeter1.getValue());
//   lpp.addRelativeHumidity(LPP_CH_ADC1VOLTAGE, potmeter2.getValue());
//   lpp.addAnalogInput(LPP_CH_TESTSIGNAL1, sineSignal.getSignal());
//   lpp.addAnalogInput(LPP_CH_TESTSIGNAL2, cosineSignal.getSignal());
//   lpp.addAnalogInput(LPP_CH_TESTSIGNAL3, triangleSignal.getSignal());
//   lpp.addAnalogInput(LPP_CH_TESTSIGNAL4, rectangleSignal.getSignal());
//   lpp.addAnalogInput(LPP_CH_TESTSIGNAL5, sawtoothSignal.getSignal());
//   lpp.addPresence(LPP_CH_PRESENCE, SAFE);
//   lpp.addAnalogOutput(LPP_CH_SET_INTERVAL, (float)currentInterval/1000);

//   // Send it off
//   rightGreenLED.setState(LED_ON);
//   ttn.sendBytes(lpp.getBuffer(), lpp.getSize(), APPLICATION_PORT_CAYENNE, false); // unconfirmed 
//   rightGreenLED.setState(LED_OFF); 
// }

// /// \brief send event driven message
// void sendAlarm(void)
// {
//   lpp.reset();
//   lpp.addPresence(LPP_CH_PRESENCE, ALARM);
//   lpp.addDigitalInput(LPP_CH_SW_RELEASE, RELEASE);

//   // Send it off
//   rightGreenLED.setState(LED_ON);
//   ttn.sendBytes(lpp.getBuffer(), lpp.getSize(), APPLICATION_PORT_CAYENNE, true);
//   rightGreenLED.setState(LED_OFF); 
// }

// /// \brief send poll to network to initiate downlink traffic
// void sendPoll(void)
// {
//   rightRedLED.setState(LED_ON);
  
//   // Send single byte to poll for incoming messages
//   ttn.poll();
//   rightRedLED.setState(LED_OFF); 
// }

// /// \brief present "knightrider" on leds
// void helloWorld(void)
// {
//   leftRedLED.setState(LED_ON);
//   delay(100);
//   leftRedLED.setState(LED_OFF);
//   leftGreenLED.setState(LED_ON);
//   delay(100);
//   leftGreenLED.setState(LED_OFF);
//   rightRedLED.setState(LED_ON);
//   delay(100);
//   rightRedLED.setState(LED_OFF);
//   rightGreenLED.setState(LED_ON);
//   delay(100);
//   rightGreenLED.setState(LED_OFF);
//   rightGreenLED.setState(LED_ON);
//   delay(100);
//   rightGreenLED.setState(LED_OFF);
//   rightRedLED.setState(LED_ON);
//   delay(100);
//   rightRedLED.setState(LED_OFF);
//   leftGreenLED.setState(LED_ON);
//   delay(100);
//   leftGreenLED.setState(LED_OFF);
//   leftRedLED.setState(LED_ON);
//   delay(100);
//   leftRedLED.setState(LED_OFF);
// }

// // \brief reset within 4 seconds while indication on led that reset is started.
// void remoteReset(void){
//   wdt_enable(WDTO_4S);
//   while (true) {
//     rightRedLED.setState(LED_OFF);
//     delay(200);
//     rightRedLED.setState(LED_ON);
//     delay(200);
//   }
// }
